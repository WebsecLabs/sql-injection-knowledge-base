---
import { getCollection } from "astro:content";
import Layout from "../layouts/Layout.astro";

// Load all entries at build time for client-side search
const mysqlEntries = await getCollection("mysql");
const mssqlEntries = await getCollection("mssql");
const oracleEntries = await getCollection("oracle");
const extrasEntries = await getCollection("extras");

// Prepare searchable data for client-side (minimal data to reduce payload)
interface SearchEntry {
  slug: string;
  title: string;
  description?: string;
  category: string;
  tags?: string[];
  collection: string;
}

const searchData: SearchEntry[] = [
  ...mysqlEntries.map((e) => ({
    slug: e.slug,
    title: e.data.title,
    description: e.data.description,
    category: e.data.category,
    tags: e.data.tags,
    collection: "mysql",
  })),
  ...mssqlEntries.map((e) => ({
    slug: e.slug,
    title: e.data.title,
    description: e.data.description,
    category: e.data.category,
    tags: e.data.tags,
    collection: "mssql",
  })),
  ...oracleEntries.map((e) => ({
    slug: e.slug,
    title: e.data.title,
    description: e.data.description,
    category: e.data.category,
    tags: e.data.tags,
    collection: "oracle",
  })),
  ...extrasEntries.map((e) => ({
    slug: e.slug,
    title: e.data.title,
    description: e.data.description,
    category: e.data.category,
    tags: e.data.tags,
    collection: "extras",
  })),
];

const baseUrl = import.meta.env.BASE_URL;
---

<Layout
  title="Search - SQL Injection KB"
  showSidebar={false}
  collections={{
    mysqlEntries,
    mssqlEntries,
    oracleEntries,
    extrasEntries,
  }}
>
  <div
    class="search-results"
    data-base-url={baseUrl}
    data-search-entries={JSON.stringify(searchData)}
  >
    <h1>Search Results</h1>

    <div class="search-info">
      <p id="search-status">Loading...</p>
      <div class="search-form">
        <form id="search-form" action={`${baseUrl}search`} method="get">
          <input
            type="text"
            id="search-input"
            name="q"
            placeholder="Search..."
            aria-label="Search"
          />
          <button type="submit">Search</button>
        </form>
      </div>
    </div>

    <div id="no-results" class="no-results" style="display: none;">
      <p>No entries found matching your query. Please try a different search term.</p>
    </div>

    <div id="initial-search" class="search-form initial-search" style="display: none;">
      <p>Enter a search term to find entries across all database types</p>
    </div>

    <div id="results-container"></div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const container = document.querySelector(".search-results") as HTMLElement;
      const baseUrl = container?.dataset.baseUrl || "/";
      const searchDataJson = container?.dataset.searchEntries || "[]";

      interface SearchEntry {
        slug: string;
        title: string;
        description?: string;
        category: string;
        tags?: string[];
        collection: string;
      }

      let searchData: SearchEntry[] = [];
      try {
        searchData = JSON.parse(searchDataJson);
      } catch {
        console.error("Failed to parse search data");
      }

      const searchInput = document.getElementById("search-input") as HTMLInputElement;
      const searchStatus = document.getElementById("search-status") as HTMLElement;
      const noResults = document.getElementById("no-results") as HTMLElement;
      const initialSearch = document.getElementById("initial-search") as HTMLElement;
      const resultsContainer = document.getElementById("results-container") as HTMLElement;

      // Escape HTML to prevent XSS
      function escapeHtml(text: string): string {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Highlight matching text
      function highlightText(text: string, query: string): string {
        if (!query || !text) return escapeHtml(text || "");
        const lowerText = text.toLowerCase();
        const lowerQuery = query.toLowerCase();

        const matches: Array<{ start: number; end: number }> = [];
        let pos = 0;
        while ((pos = lowerText.indexOf(lowerQuery, pos)) !== -1) {
          matches.push({ start: pos, end: pos + lowerQuery.length });
          pos += lowerQuery.length;
        }

        if (matches.length === 0) return escapeHtml(text);

        let result = "";
        let lastEnd = 0;
        for (const match of matches) {
          result += escapeHtml(text.slice(lastEnd, match.start));
          result += "<mark>" + escapeHtml(text.slice(match.start, match.end)) + "</mark>";
          lastEnd = match.end;
        }
        result += escapeHtml(text.slice(lastEnd));
        return result;
      }

      // Search function
      function performSearch(query: string) {
        const normalizedQuery = query.toLowerCase().trim();

        if (!normalizedQuery) {
          searchStatus.textContent = "";
          noResults.style.display = "none";
          initialSearch.style.display = "block";
          resultsContainer.innerHTML = "";
          return;
        }

        initialSearch.style.display = "none";

        // Filter entries
        const matches = searchData.filter((entry) => {
          const titleMatch = entry.title.toLowerCase().includes(normalizedQuery);
          const descMatch = entry.description?.toLowerCase().includes(normalizedQuery) || false;
          const categoryMatch = entry.category.toLowerCase().includes(normalizedQuery);
          const tagsMatch =
            entry.tags?.some((t) => t.toLowerCase().includes(normalizedQuery)) || false;
          return titleMatch || descMatch || categoryMatch || tagsMatch;
        });

        // Group by collection
        const grouped: Record<string, SearchEntry[]> = {};
        for (const entry of matches) {
          if (!grouped[entry.collection]) grouped[entry.collection] = [];
          grouped[entry.collection].push(entry);
        }

        // Update UI
        searchStatus.textContent = `Found ${matches.length} ${matches.length === 1 ? "result" : "results"} for "${query}"`;

        if (matches.length === 0) {
          noResults.style.display = "block";
          resultsContainer.innerHTML = "";
          return;
        }

        noResults.style.display = "none";

        // Render results
        const collectionLabels: Record<string, string> = {
          mysql: "MySQL",
          mssql: "MSSQL",
          oracle: "Oracle",
          extras: "Other Resources",
        };

        let html = "";
        for (const [collection, entries] of Object.entries(grouped)) {
          html += `<div class="result-section">
            <h2>${collectionLabels[collection] || collection} (${entries.length})</h2>
            <ul class="result-list">`;

          for (const entry of entries) {
            const href = `${baseUrl}${collection}/${entry.slug}`;
            html += `<li>
              <a href="${href}" class="result-card">
                <div class="result-title">${highlightText(entry.title, normalizedQuery)}</div>
                <div class="result-category">${escapeHtml(entry.category)}</div>
                ${entry.description ? `<div class="result-description">${highlightText(entry.description, normalizedQuery)}</div>` : ""}
                ${entry.tags?.length ? `<div class="result-tags">${entry.tags.map((t) => `<span class="tag">${escapeHtml(t)}</span>`).join("")}</div>` : ""}
              </a>
            </li>`;
          }

          html += `</ul></div>`;
        }

        resultsContainer.innerHTML = html;
      }

      // Get query from URL
      const urlParams = new URLSearchParams(window.location.search);
      const queryParam = urlParams.get("q") || "";

      // Set input value and perform search
      searchInput.value = queryParam;
      performSearch(queryParam);

      // Update title if query exists
      if (queryParam) {
        const maxLen = 50;
        const truncated =
          queryParam.length > maxLen ? queryParam.slice(0, maxLen) + "â€¦" : queryParam;
        document.title = `Search Results for "${truncated}" - SQL Injection KB`;
      }
    });
  </script>
</Layout>

<style>
  .search-results {
    max-width: 900px;
    margin: 0 auto;
    padding: 1rem;
  }

  h1 {
    margin-bottom: 2rem;
    color: var(--color-primary);
  }

  .search-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .search-info p {
    font-size: 1.1rem;
    opacity: 0.8;
  }

  .search-form {
    margin-bottom: 2rem;
  }

  .initial-search p {
    margin-bottom: 1rem;
    font-size: 1.1rem;
  }

  .search-form form {
    display: flex;
    gap: 0.5rem;
  }

  .search-form input {
    padding: 0.5rem 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 1rem;
    min-width: 300px;
  }

  .search-form button {
    padding: 0.5rem 1rem;
    background-color: var(--color-primary);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }

  .no-results {
    background-color: #f8f9fa;
    padding: 2rem;
    border-radius: 8px;
    text-align: center;
    margin: 2rem 0;
  }

  .result-section {
    margin-bottom: 3rem;
  }

  .result-section h2 {
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #eaeaea;
  }

  .result-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 1rem;
  }

  .result-card {
    display: block;
    padding: 1.25rem;
    border-radius: 8px;
    background-color: #f8f9fa;
    text-decoration: none;
    color: inherit;
    transition:
      transform 0.2s,
      box-shadow 0.2s;
    height: 100%;
  }

  .result-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .result-title {
    font-weight: 600;
    font-size: 1.1rem;
    margin-bottom: 0.5rem;
    color: var(--color-primary);
  }

  .result-category {
    display: inline-block;
    font-size: 0.8rem;
    background-color: #e9ecef;
    color: #495057;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    margin-bottom: 0.75rem;
  }

  .result-description {
    font-size: 0.9rem;
    color: #495057;
    margin-bottom: 0.75rem;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .result-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.75rem;
  }

  .tag {
    font-size: 0.75rem;
    padding: 0.2rem 0.5rem;
    background-color: var(--color-primary-light);
    color: var(--color-primary);
    border-radius: 4px;
  }

  mark {
    background-color: #fff3cd;
    color: #664d03;
    padding: 0 2px;
    border-radius: 2px;
  }

  @media (max-width: 768px) {
    .search-info {
      flex-direction: column;
      align-items: flex-start;
    }

    .result-list {
      grid-template-columns: 1fr;
    }

    .search-form form {
      flex-direction: column;
    }

    .search-form input {
      min-width: 100%;
    }
  }
</style>
