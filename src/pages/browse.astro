---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import MarkdownEntry from "../components/MarkdownEntry.astro";
import { COLLECTION_TYPES } from "../utils/constants";

// Check for query parameters to determine which collection to load
const url = new URL(Astro.request.url);
const typeParam = url.searchParams.get("type");
const slug = url.searchParams.get("slug");

// Validate type parameter
const type = (
  COLLECTION_TYPES.includes(typeParam as (typeof COLLECTION_TYPES)[number]) ? typeParam : "mysql"
) as (typeof COLLECTION_TYPES)[number];

// Only load the collection we actually need
let entries: CollectionEntry<"mysql" | "mssql" | "oracle" | "extras">[];
switch (type) {
  case "mssql":
    entries = await getCollection("mssql");
    break;
  case "oracle":
    entries = await getCollection("oracle");
    break;
  case "extras":
    entries = await getCollection("extras");
    break;
  default:
    entries = await getCollection("mysql");
    break;
}

// Find the entry to display
let currentEntry: CollectionEntry<"mysql" | "mssql" | "oracle" | "extras"> | undefined;
if (slug) {
  currentEntry = entries.find((entry) => entry.slug === slug);
}

// If no entry was found or no slug provided, use the intro page or first entry
if (!currentEntry) {
  currentEntry = entries.find((entry) => entry.slug === "intro") || entries[0];
}

// Handle empty collection case
if (!currentEntry) {
  return Astro.redirect(import.meta.env.BASE_URL);
}

// Determine page title
const pageTitle = `${currentEntry.data.title} | SQL Injection KB`;

// Create collections object to pass to Layout
const collections: Record<string, typeof entries> = {};
switch (type) {
  case "mssql":
    collections.mssqlEntries = entries;
    break;
  case "oracle":
    collections.oracleEntries = entries;
    break;
  case "extras":
    collections.extrasEntries = entries;
    break;
  default:
    collections.mysqlEntries = entries;
    break;
}
---

<Layout title={pageTitle} collections={collections}>
  <div
    class="browse-container"
    transition:animate="slide"
    data-base-url={import.meta.env.BASE_URL}
    data-collection-types={JSON.stringify(COLLECTION_TYPES)}
  >
    <div class="browse-header" transition:animate="fade">
      <div class="breadcrumbs">
        <a href={import.meta.env.BASE_URL}>Home</a>
        <span class="separator">/</span>
        <a href={`${import.meta.env.BASE_URL}browse?type=${currentEntry.collection}`}
          >{currentEntry.collection.toUpperCase()}</a
        >
        <span class="separator">/</span>
        <span>{currentEntry.data.title}</span>
      </div>
    </div>

    <MarkdownEntry entry={currentEntry} />
  </div>

  <script>
    // Enhance sidebar navigation to update URL parameters
    document.addEventListener("DOMContentLoaded", () => {
      const container = document.querySelector(".browse-container");
      const baseUrl = container?.getAttribute("data-base-url") || "/";

      // Parse collection types from data attribute, with fallback
      const defaultCollectionTypes = ["mysql", "mssql", "oracle", "extras"];
      let collectionTypes: string[] = defaultCollectionTypes;
      try {
        const typesAttr = container?.getAttribute("data-collection-types");
        if (typesAttr) {
          const parsed = JSON.parse(typesAttr);
          if (
            Array.isArray(parsed) &&
            parsed.length > 0 &&
            parsed.every((t) => typeof t === "string")
          ) {
            collectionTypes = parsed;
          }
        }
      } catch {
        // Parsing failed, use default
        console.warn("Failed to parse collection types, using defaults");
      }

      const sidebarLinks = document.querySelectorAll(".sidebar-nav a");

      sidebarLinks.forEach((link) => {
        const href = link.getAttribute("href");

        // We'll only modify the behavior if it's linking to a specific entry
        // Use includes() to handle BASE_URL subdirectory deployments
        if (href && collectionTypes.some((t) => href.includes(`/${t}/`))) {
          link.addEventListener("click", (e) => {
            e.preventDefault();

            // Parse the href to get type and slug
            let type = "";
            let slug = "";

            for (const collType of collectionTypes) {
              const pattern = `/${collType}/`;
              const idx = href.indexOf(pattern);
              if (idx !== -1) {
                type = collType;
                // Get everything after the pattern as the slug
                slug = href.slice(idx + pattern.length).replace(/\/$/, "");
                break;
              }
            }

            if (type && slug) {
              // Navigate to the entry (full page navigation updates history automatically)
              loadEntry(type, slug);
            }
          });
        }
      });

      // Navigate to entry page
      function loadEntry(type: string, slug: string) {
        window.location.href = `${baseUrl}browse?type=${type}&slug=${slug}`;
      }
    });
  </script>
</Layout>

<style>
  .browse-container {
    max-width: 900px;
    margin: 0 auto;
  }

  .browse-header {
    margin-bottom: 1.5rem;
  }

  .breadcrumbs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--color-text-light);
  }

  .breadcrumbs a {
    color: var(--color-primary);
    text-decoration: none;
  }

  .breadcrumbs a:hover {
    text-decoration: underline;
  }

  .separator {
    color: var(--color-border-light);
  }
</style>
