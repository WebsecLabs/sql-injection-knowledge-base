---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import MarkdownEntry from "../components/MarkdownEntry.astro";

// Check for query parameters to determine which collection to load
const url = new URL(Astro.request.url);
const type = url.searchParams.get("type") || "mysql";
const slug = url.searchParams.get("slug");

// Only load the collection we actually need
let entries: CollectionEntry<"mysql" | "mssql" | "oracle" | "extras">[];
switch (type) {
  case "mssql":
    entries = await getCollection("mssql");
    break;
  case "oracle":
    entries = await getCollection("oracle");
    break;
  case "extras":
    entries = await getCollection("extras");
    break;
  default:
    entries = await getCollection("mysql");
    break;
}

// Find the entry to display
let currentEntry: CollectionEntry<"mysql" | "mssql" | "oracle" | "extras"> | undefined;
if (slug) {
  currentEntry = entries.find((entry) => entry.slug === slug);
}

// If no entry was found or no slug provided, use the intro page or first entry
if (!currentEntry) {
  currentEntry = entries.find((entry) => entry.slug === "intro") || entries[0];
}

// Handle empty collection case
if (!currentEntry) {
  return Astro.redirect(import.meta.env.BASE_URL);
}

// Determine page title
const pageTitle = `${currentEntry.data.title} | SQL Injection KB`;

// Create collections object to pass to Layout
const collections: Record<string, typeof entries> = {};
switch (type) {
  case "mssql":
    collections.mssqlEntries = entries;
    break;
  case "oracle":
    collections.oracleEntries = entries;
    break;
  case "extras":
    collections.extrasEntries = entries;
    break;
  default:
    collections.mysqlEntries = entries;
    break;
}
---

<Layout title={pageTitle} collections={collections}>
  <div class="browse-container" transition:animate="slide" data-base-url={import.meta.env.BASE_URL}>
    <div class="browse-header" transition:animate="fade">
      <div class="breadcrumbs">
        <a href={import.meta.env.BASE_URL}>Home</a>
        <span class="separator">/</span>
        <a href={`${import.meta.env.BASE_URL}browse?type=${currentEntry.collection}`}
          >{currentEntry.collection.toUpperCase()}</a
        >
        <span class="separator">/</span>
        <span>{currentEntry.data.title}</span>
      </div>
    </div>

    <MarkdownEntry entry={currentEntry} />
  </div>

  <script>
    // Enhance sidebar navigation to update URL parameters
    document.addEventListener("DOMContentLoaded", () => {
      const container = document.querySelector(".browse-container");
      const baseUrl = container?.getAttribute("data-base-url") || "/";
      const sidebarLinks = document.querySelectorAll(".sidebar-nav a");

      sidebarLinks.forEach((link) => {
        const href = link.getAttribute("href");

        // We'll only modify the behavior if it's linking to a specific entry
        // Use includes() to handle BASE_URL subdirectory deployments
        if (
          href &&
          (href.includes("/mysql/") ||
            href.includes("/mssql/") ||
            href.includes("/oracle/") ||
            href.includes("/extras/"))
        ) {
          link.addEventListener("click", (e) => {
            e.preventDefault();

            // Parse the href to get type and slug
            // Find the collection type by looking for known patterns
            const collectionTypes = ["mysql", "mssql", "oracle", "extras"];
            let type = "";
            let slug = "";

            for (const collType of collectionTypes) {
              const pattern = `/${collType}/`;
              const idx = href.indexOf(pattern);
              if (idx !== -1) {
                type = collType;
                // Get everything after the pattern as the slug
                slug = href.slice(idx + pattern.length).replace(/\/$/, "");
                break;
              }
            }

            if (type && slug) {
              // Navigate to the entry (full page navigation updates history automatically)
              loadEntry(type, slug);
            }
          });
        }
      });

      // Function to load entry content via fetch
      function loadEntry(type: string, slug: string) {
        try {
          // Reload the page with the new parameters
          window.location.href = `${baseUrl}browse?type=${type}&slug=${slug}`;
        } catch (error) {
          console.error("Error loading entry:", error);
        }
      }

      // Handle back/forward browser navigation
      window.addEventListener("popstate", () => {
        const url = new URL(window.location.href);
        const type = url.searchParams.get("type");
        const slug = url.searchParams.get("slug");

        if (type && slug) {
          loadEntry(type, slug);
        }
      });
    });
  </script>
</Layout>

<style>
  .browse-container {
    max-width: 900px;
    margin: 0 auto;
  }

  .browse-header {
    margin-bottom: 1.5rem;
  }

  .breadcrumbs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: #718096;
  }

  .breadcrumbs a {
    color: var(--color-primary);
    text-decoration: none;
  }

  .breadcrumbs a:hover {
    text-decoration: underline;
  }

  .separator {
    color: #cbd5e0;
  }
</style>
