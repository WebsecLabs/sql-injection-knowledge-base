---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../../layouts/Layout.astro";
import MarkdownEntry from "../../components/MarkdownEntry.astro";
import EntryNavigation from "../../components/EntryNavigation.astro";
import { COLLECTION_TYPES, COLLECTION_LABELS, type ValidCollection } from "../../utils/constants";
import {
  getAdjacentEntries,
  getFirstEntrySlug,
  sortEntriesByCategory,
} from "../../utils/entryUtils";

// Union type for entries from any valid collection
type AnyEntry = CollectionEntry<ValidCollection>;

// Generate static paths for all entries across all collections
export async function getStaticPaths() {
  const paths: Array<{
    params: { collection: string; slug: string };
    props: { entry: AnyEntry; collectionName: ValidCollection };
  }> = [];

  for (const collectionName of COLLECTION_TYPES) {
    const entries = await getCollection(collectionName);
    for (const entry of entries) {
      paths.push({
        params: { collection: collectionName, slug: entry.slug },
        props: { entry: entry as AnyEntry, collectionName },
      });
    }
  }

  return paths;
}

interface Props {
  entry: AnyEntry;
  collectionName: ValidCollection;
}

const { entry, collectionName } = Astro.props;

// Load all collections for sidebar navigation
const mysqlEntries = await getCollection("mysql");
const mariadbEntries = await getCollection("mariadb");
const mssqlEntries = await getCollection("mssql");
const oracleEntries = await getCollection("oracle");
const postgresqlEntries = await getCollection("postgresql");
const extrasEntries = await getCollection("extras");

// Build page title
const collectionTitle = COLLECTION_LABELS[collectionName];
const pageTitle = `${entry.data.title} | ${collectionTitle} | SQL Injection KB`;

// Build collections object for Layout (uses *Entries key naming for sidebar)
const collections = {
  mysqlEntries,
  mariadbEntries,
  mssqlEntries,
  oracleEntries,
  postgresqlEntries,
  extrasEntries,
};

// Get current collection entries for navigation (sort once and reuse)
const entriesKey = `${collectionName}Entries` as keyof typeof collections;
const currentCollectionEntries = collections[entriesKey] as AnyEntry[];
const sortedEntries = sortEntriesByCategory(currentCollectionEntries);
const { previous, next } = getAdjacentEntries(currentCollectionEntries, entry.slug, sortedEntries);

// Get first entry slug for breadcrumb (uses pre-sorted entries to avoid re-sorting)
const firstEntrySlug = getFirstEntrySlug(currentCollectionEntries, sortedEntries) ?? "intro";

// Render entry to extract headings for Table of Contents
// Note: Astro caches render() calls, so this doesn't duplicate work done in MarkdownEntry
const { headings } = await entry.render();

// Filter to H2 and H3 headings for TOC (depth 2 and 3)
const tocHeadings = headings.filter((h) => h.depth === 2 || h.depth === 3);
---

<Layout title={pageTitle} collections={collections} tocHeadings={tocHeadings}>
  <div class="entry-container" transition:animate="slide">
    <div class="entry-header" transition:animate="fade">
      <nav class="breadcrumbs" aria-label="Breadcrumb">
        <a href={import.meta.env.BASE_URL}>Home</a>
        <span class="separator" aria-hidden="true">/</span>
        <a href={`${import.meta.env.BASE_URL}${collectionName}/${firstEntrySlug}`}
          >{collectionTitle}</a
        >
        <span class="separator" aria-hidden="true">/</span>
        <span aria-current="page">{entry.data.title}</span>
      </nav>
    </div>

    <MarkdownEntry entry={entry} />

    <EntryNavigation collection={collectionName} previous={previous} next={next} />
  </div>
</Layout>

<style>
  .entry-container {
    max-width: 900px;
    margin: 0 auto;
  }

  .entry-header {
    margin-bottom: 1.5rem;
  }

  .breadcrumbs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: var(--color-text-light);
  }

  .breadcrumbs a {
    color: var(--color-primary);
    text-decoration: none;
  }

  .breadcrumbs a:hover {
    text-decoration: underline;
  }

  .separator {
    color: var(--color-border-light);
  }
</style>
